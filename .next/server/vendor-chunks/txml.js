"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/txml";
exports.ids = ["vendor-chunks/txml"];
exports.modules = {

/***/ "(rsc)/./node_modules/txml/dist/txml.mjs":
/*!*****************************************!*\
  !*** ./node_modules/txml/dist/txml.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   getElementById: () => (/* binding */ getElementById),\n/* harmony export */   getElementsByClassName: () => (/* binding */ getElementsByClassName),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   simplify: () => (/* binding */ simplify),\n/* harmony export */   simplifyLostLess: () => (/* binding */ simplifyLostLess),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   toContentString: () => (/* binding */ toContentString)\n/* harmony export */ });\n// ==ClosureCompiler==\n// @output_file_name default.js\n// @compilation_level SIMPLE_OPTIMIZATIONS\n// ==/ClosureCompiler==\n// module.exports = {\n//     parse: parse,\n//     simplify: simplify,\n//     simplifyLostLess: simplifyLostLess,\n//     filter: filter,\n//     stringify: stringify,\n//     toContentString: toContentString,\n//     getElementById: getElementById,\n//     getElementsByClassName: getElementsByClassName,\n//     transformStream: transformStream,\n// };\n\n/**\n * @author: Tobias Nickel\n * @created: 06.04.2015\n * I needed a small xmlparser chat can be used in a worker.\n */\n\n/**\n * @typedef tNode \n * @property {string} tagName \n * @property {object} attributes\n * @property {(tNode|string)[]} children \n **/\n\n/**\n * @typedef TParseOptions\n * @property {number} [pos]\n * @property {string[]} [noChildNodes]\n * @property {boolean} [setPos]\n * @property {boolean} [keepComments] \n * @property {boolean} [keepWhitespace]\n * @property {boolean} [simplify]\n * @property {(a: tNode, b: tNode) => boolean} [filter]\n */\n\n/**\n * parseXML / html into a DOM Object. with no validation and some failur tolerance\n * @param {string} S your XML to parse\n * @param {TParseOptions} [options]  all other options:\n * @return {(tNode | string)[]}\n */\nfunction parse(S, options) {\n    \"txml\";\n    options = options || {};\n\n    var pos = options.pos || 0;\n    var keepComments = !!options.keepComments;\n    var keepWhitespace = !!options.keepWhitespace;\n\n    var openBracket = \"<\";\n    var openBracketCC = \"<\".charCodeAt(0);\n    var closeBracket = \">\";\n    var closeBracketCC = \">\".charCodeAt(0);\n    var minusCC = \"-\".charCodeAt(0);\n    var slashCC = \"/\".charCodeAt(0);\n    var exclamationCC = '!'.charCodeAt(0);\n    var singleQuoteCC = \"'\".charCodeAt(0);\n    var doubleQuoteCC = '\"'.charCodeAt(0);\n    var openCornerBracketCC = '['.charCodeAt(0);\n    var closeCornerBracketCC = ']'.charCodeAt(0);\n\n\n    /**\n     * parsing a list of entries\n     */\n    function parseChildren(tagName) {\n        var children = [];\n        while (S[pos]) {\n            if (S.charCodeAt(pos) == openBracketCC) {\n                if (S.charCodeAt(pos + 1) === slashCC) {\n                    var closeStart = pos + 2;\n                    pos = S.indexOf(closeBracket, pos);\n\n                    var closeTag = S.substring(closeStart, pos);\n                    if (closeTag.indexOf(tagName) == -1) {\n                        var parsedText = S.substring(0, pos).split('\\n');\n                        throw new Error(\n                            'Unexpected close tag\\nLine: ' + (parsedText.length - 1) +\n                            '\\nColumn: ' + (parsedText[parsedText.length - 1].length + 1) +\n                            '\\nChar: ' + S[pos]\n                        );\n                    }\n\n                    if (pos + 1) pos += 1;\n\n                    return children;\n                } else if (S.charCodeAt(pos + 1) === exclamationCC) {\n                    if (S.charCodeAt(pos + 2) == minusCC) {\n                        //comment support\n                        const startCommentPos = pos;\n                        while (pos !== -1 && !(S.charCodeAt(pos) === closeBracketCC && S.charCodeAt(pos - 1) == minusCC && S.charCodeAt(pos - 2) == minusCC && pos != -1)) {\n                            pos = S.indexOf(closeBracket, pos + 1);\n                        }\n                        if (pos === -1) {\n                            pos = S.length;\n                        }\n                        if (keepComments) {\n                            children.push(S.substring(startCommentPos, pos + 1));\n                        }\n                    } else if (\n                        S.charCodeAt(pos + 2) === openCornerBracketCC &&\n                        S.charCodeAt(pos + 8) === openCornerBracketCC &&\n                        S.substr(pos + 3, 5).toLowerCase() === 'cdata'\n                    ) {\n                        // cdata\n                        var cdataEndIndex = S.indexOf(']]>', pos);\n                        if (cdataEndIndex == -1) {\n                            children.push(S.substr(pos + 9));\n                            pos = S.length;\n                        } else {\n                            children.push(S.substring(pos + 9, cdataEndIndex));\n                            pos = cdataEndIndex + 3;\n                        }\n                        continue;\n                    } else {\n                        // doctypesupport\n                        const startDoctype = pos + 1;\n                        pos += 2;\n                        var encapsuled = false;\n                        while ((S.charCodeAt(pos) !== closeBracketCC || encapsuled === true) && S[pos]) {\n                            if (S.charCodeAt(pos) === openCornerBracketCC) {\n                                encapsuled = true;\n                            } else if (encapsuled === true && S.charCodeAt(pos) === closeCornerBracketCC) {\n                                encapsuled = false;\n                            }\n                            pos++;\n                        }\n                        children.push(S.substring(startDoctype, pos));\n                    }\n                    pos++;\n                    continue;\n                }\n                var node = parseNode();\n                children.push(node);\n                if (node.tagName[0] === '?') {\n                    children.push(...node.children);\n                    node.children = [];\n                }\n            } else {\n                var text = parseText();\n                if (keepWhitespace) {\n                    if (text.length > 0) {\n                        children.push(text);\n                    }\n                } else {\n                    var trimmed = text.trim();\n                    if (trimmed.length > 0) {\n                        children.push(trimmed);\n                    }\n                }\n                pos++;\n            }\n        }\n        return children;\n    }\n\n    /**\n     *    returns the text outside of texts until the first '<'\n     */\n    function parseText() {\n        var start = pos;\n        pos = S.indexOf(openBracket, pos) - 1;\n        if (pos === -2)\n            pos = S.length;\n        return S.slice(start, pos + 1);\n    }\n    /**\n     *    returns text until the first nonAlphabetic letter\n     */\n    var nameSpacer = '\\r\\n\\t>/= ';\n\n    function parseName() {\n        var start = pos;\n        while (nameSpacer.indexOf(S[pos]) === -1 && S[pos]) {\n            pos++;\n        }\n        return S.slice(start, pos);\n    }\n    /**\n     *    is parsing a node, including tagName, Attributes and its children,\n     * to parse children it uses the parseChildren again, that makes the parsing recursive\n     */\n    var NoChildNodes = options.noChildNodes || ['img', 'br', 'input', 'meta', 'link', 'hr'];\n\n    function parseNode() {\n        pos++;\n        const tagName = parseName();\n        const attributes = {};\n        let children = [];\n\n        // parsing attributes\n        while (S.charCodeAt(pos) !== closeBracketCC && S[pos]) {\n            var c = S.charCodeAt(pos);\n            if ((c > 64 && c < 91) || (c > 96 && c < 123)) {\n                //if('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(S[pos])!==-1 ){\n                var name = parseName();\n                // search beginning of the string\n                var code = S.charCodeAt(pos);\n                while (code && code !== singleQuoteCC && code !== doubleQuoteCC && !((code > 64 && code < 91) || (code > 96 && code < 123)) && code !== closeBracketCC) {\n                    pos++;\n                    code = S.charCodeAt(pos);\n                }\n                if (code === singleQuoteCC || code === doubleQuoteCC) {\n                    var value = parseString();\n                    if (pos === -1) {\n                        return {\n                            tagName,\n                            attributes,\n                            children,\n                        };\n                    }\n                } else {\n                    value = null;\n                    pos--;\n                }\n                attributes[name] = value;\n            }\n            pos++;\n        }\n        // optional parsing of children\n        if (S.charCodeAt(pos - 1) !== slashCC) {\n            if (tagName == \"script\") {\n                var start = pos + 1;\n                pos = S.indexOf('</script>', pos);\n                children = [S.slice(start, pos)];\n                pos += 9;\n            } else if (tagName == \"style\") {\n                var start = pos + 1;\n                pos = S.indexOf('</style>', pos);\n                children = [S.slice(start, pos)];\n                pos += 8;\n            } else if (NoChildNodes.indexOf(tagName) === -1) {\n                pos++;\n                children = parseChildren(tagName);\n            } else {\n                pos++;\n            }\n        } else {\n            pos++;\n        }\n        return {\n            tagName,\n            attributes,\n            children,\n        };\n    }\n\n    /**\n     *    is parsing a string, that starts with a char and with the same usually  ' or \"\n     */\n\n    function parseString() {\n        var startChar = S[pos];\n        var startpos = pos + 1;\n        pos = S.indexOf(startChar, startpos);\n        return S.slice(startpos, pos);\n    }\n\n    /**\n     *\n     */\n    function findElements() {\n        var r = new RegExp('\\\\s' + options.attrName + '\\\\s*=[\\'\"]' + options.attrValue + '[\\'\"]').exec(S);\n        if (r) {\n            return r.index;\n        } else {\n            return -1;\n        }\n    }\n\n    var out = null;\n    if (options.attrValue !== undefined) {\n        options.attrName = options.attrName || 'id';\n        var out = [];\n\n        while ((pos = findElements()) !== -1) {\n            pos = S.lastIndexOf('<', pos);\n            if (pos !== -1) {\n                out.push(parseNode());\n            }\n            S = S.substr(pos);\n            pos = 0;\n        }\n    } else if (options.parseNode) {\n        out = parseNode();\n    } else {\n        out = parseChildren('');\n    }\n\n    if (options.filter) {\n        out = filter(out, options.filter);\n    }\n\n    if (options.simplify) {\n        return simplify(Array.isArray(out) ? out : [out]);\n    }\n\n    if (options.setPos) {\n        out.pos = pos;\n    }\n\n    return out;\n}\n\n/**\n * transform the DomObject to an object that is like the object of PHP`s simple_xmp_load_*() methods.\n * this format helps you to write that is more likely to keep your program working, even if there a small changes in the XML schema.\n * be aware, that it is not possible to reproduce the original xml from a simplified version, because the order of elements is not saved.\n * therefore your program will be more flexible and easier to read.\n *\n * @param {tNode[]} children the childrenList\n */\nfunction simplify(children) {\n    var out = {};\n    if (!children.length) {\n        return '';\n    }\n\n    if (children.length === 1 && typeof children[0] == 'string') {\n        return children[0];\n    }\n    // map each object\n    children.forEach(function(child) {\n        if (typeof child !== 'object') {\n            return;\n        }\n        if (!out[child.tagName])\n            out[child.tagName] = [];\n        var kids = simplify(child.children);\n        out[child.tagName].push(kids);\n        if (Object.keys(child.attributes).length && typeof kids !== 'string') {\n            kids._attributes = child.attributes;\n        }\n    });\n\n    for (var i in out) {\n        if (out[i].length == 1) {\n            out[i] = out[i][0];\n        }\n    }\n\n    return out;\n}\n\n/**\n * similar to simplify, but lost less\n *\n * @param {tNode[]} children the childrenList\n */\nfunction simplifyLostLess(children, parentAttributes = {}) {\n    var out = {};\n    if (!children.length) {\n        return out;\n    }\n\n    if (children.length === 1 && typeof children[0] == 'string') {\n        return Object.keys(parentAttributes).length ? {\n            _attributes: parentAttributes,\n            value: children[0]\n        } : children[0];\n    }\n    // map each object\n    children.forEach(function(child) {\n        if (typeof child !== 'object') {\n            return;\n        }\n        if (!out[child.tagName])\n            out[child.tagName] = [];\n        var kids = simplifyLostLess(child.children || [], child.attributes);\n        out[child.tagName].push(kids);\n        if (Object.keys(child.attributes).length) {\n            kids._attributes = child.attributes;\n        }\n    });\n\n    return out;\n}\n/**\n * behaves the same way as Array.filter, if the filter method return true, the element is in the resultList\n * @params children{Array} the children of a node\n * @param f{function} the filter method\n */\nfunction filter(children, f, dept = 0, path = '') {\n    var out = [];\n    children.forEach(function(child, i) {\n        if (typeof(child) === 'object' && f(child, i, dept, path)) out.push(child);\n        if (child.children) {\n            var kids = filter(child.children, f, dept + 1, (path ? path + '.' : '') + i + '.' + child.tagName);\n            out = out.concat(kids);\n        }\n    });\n    return out;\n}\n/**\n * stringify a previously parsed string object.\n * this is useful,\n *  1. to remove whitespace\n * 2. to recreate xml data, with some changed data.\n * @param {tNode} O the object to Stringify\n */\nfunction stringify(O) {\n    var out = '';\n\n    function writeChildren(O) {\n        if (O) {\n            for (var i = 0; i < O.length; i++) {\n                if (typeof O[i] == 'string') {\n                    out += O[i].trim();\n                } else {\n                    writeNode(O[i]);\n                }\n            }\n        }\n    }\n\n    function writeNode(N) {\n        out += \"<\" + N.tagName;\n        for (var i in N.attributes) {\n            if (N.attributes[i] === null) {\n                out += ' ' + i;\n            } else if (N.attributes[i].indexOf('\"') === -1) {\n                out += ' ' + i + '=\"' + N.attributes[i].trim() + '\"';\n            } else {\n                out += ' ' + i + \"='\" + N.attributes[i].trim() + \"'\";\n            }\n        }\n        if (N.tagName[0] === '?') {\n            out += '?>';\n            return;\n        }\n        out += '>';\n        writeChildren(N.children);\n        out += '</' + N.tagName + '>';\n    }\n    writeChildren(O);\n\n    return out;\n}\n\n/**\n * use this method to read the text content, of some node.\n * It is great if you have mixed content like:\n * this text has some <b>big</b> text and a <a href=''>link</a>\n * @return {string}\n */\nfunction toContentString(tDom) {\n    if (Array.isArray(tDom)) {\n        var out = '';\n        tDom.forEach(function(e) {\n            out += ' ' + toContentString(e);\n            out = out.trim();\n        });\n        return out;\n    } else if (typeof tDom === 'object') {\n        return toContentString(tDom.children)\n    } else {\n        return ' ' + tDom;\n    }\n}\nfunction getElementById(S, id, simplified) {\n    var out = parse(S, {\n        attrValue: id\n    });\n    return simplified ? tXml.simplify(out) : out[0];\n}\nfunction getElementsByClassName(S, classname, simplified) {\n    const out = parse(S, {\n        attrName: 'class',\n        attrValue: '[a-zA-Z0-9- ]*' + classname + '[a-zA-Z0-9- ]*'\n    });\n    return simplified ? tXml.simplify(out) : out;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHhtbC9kaXN0L3R4bWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxrQkFBa0I7QUFDaEM7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsaUNBQWlDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUV5SCIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHh0b2pzb24vLi9ub2RlX21vZHVsZXMvdHhtbC9kaXN0L3R4bWwubWpzPzY2MmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gPT1DbG9zdXJlQ29tcGlsZXI9PVxuLy8gQG91dHB1dF9maWxlX25hbWUgZGVmYXVsdC5qc1xuLy8gQGNvbXBpbGF0aW9uX2xldmVsIFNJTVBMRV9PUFRJTUlaQVRJT05TXG4vLyA9PS9DbG9zdXJlQ29tcGlsZXI9PVxuLy8gbW9kdWxlLmV4cG9ydHMgPSB7XG4vLyAgICAgcGFyc2U6IHBhcnNlLFxuLy8gICAgIHNpbXBsaWZ5OiBzaW1wbGlmeSxcbi8vICAgICBzaW1wbGlmeUxvc3RMZXNzOiBzaW1wbGlmeUxvc3RMZXNzLFxuLy8gICAgIGZpbHRlcjogZmlsdGVyLFxuLy8gICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5LFxuLy8gICAgIHRvQ29udGVudFN0cmluZzogdG9Db250ZW50U3RyaW5nLFxuLy8gICAgIGdldEVsZW1lbnRCeUlkOiBnZXRFbGVtZW50QnlJZCxcbi8vICAgICBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lOiBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lLFxuLy8gICAgIHRyYW5zZm9ybVN0cmVhbTogdHJhbnNmb3JtU3RyZWFtLFxuLy8gfTtcblxuLyoqXG4gKiBAYXV0aG9yOiBUb2JpYXMgTmlja2VsXG4gKiBAY3JlYXRlZDogMDYuMDQuMjAxNVxuICogSSBuZWVkZWQgYSBzbWFsbCB4bWxwYXJzZXIgY2hhdCBjYW4gYmUgdXNlZCBpbiBhIHdvcmtlci5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHROb2RlIFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhZ05hbWUgXG4gKiBAcHJvcGVydHkge29iamVjdH0gYXR0cmlidXRlc1xuICogQHByb3BlcnR5IHsodE5vZGV8c3RyaW5nKVtdfSBjaGlsZHJlbiBcbiAqKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBUUGFyc2VPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3Bvc11cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtub0NoaWxkTm9kZXNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzZXRQb3NdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZWVwQ29tbWVudHNdIFxuICogQHByb3BlcnR5IHtib29sZWFufSBba2VlcFdoaXRlc3BhY2VdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaW1wbGlmeV1cbiAqIEBwcm9wZXJ0eSB7KGE6IHROb2RlLCBiOiB0Tm9kZSkgPT4gYm9vbGVhbn0gW2ZpbHRlcl1cbiAqL1xuXG4vKipcbiAqIHBhcnNlWE1MIC8gaHRtbCBpbnRvIGEgRE9NIE9iamVjdC4gd2l0aCBubyB2YWxpZGF0aW9uIGFuZCBzb21lIGZhaWx1ciB0b2xlcmFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBTIHlvdXIgWE1MIHRvIHBhcnNlXG4gKiBAcGFyYW0ge1RQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSAgYWxsIG90aGVyIG9wdGlvbnM6XG4gKiBAcmV0dXJuIHsodE5vZGUgfCBzdHJpbmcpW119XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKFMsIG9wdGlvbnMpIHtcbiAgICBcInR4bWxcIjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBwb3MgPSBvcHRpb25zLnBvcyB8fCAwO1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSAhIW9wdGlvbnMua2VlcENvbW1lbnRzO1xuICAgIHZhciBrZWVwV2hpdGVzcGFjZSA9ICEhb3B0aW9ucy5rZWVwV2hpdGVzcGFjZTtcblxuICAgIHZhciBvcGVuQnJhY2tldCA9IFwiPFwiO1xuICAgIHZhciBvcGVuQnJhY2tldENDID0gXCI8XCIuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgY2xvc2VCcmFja2V0ID0gXCI+XCI7XG4gICAgdmFyIGNsb3NlQnJhY2tldENDID0gXCI+XCIuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgbWludXNDQyA9IFwiLVwiLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHNsYXNoQ0MgPSBcIi9cIi5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBleGNsYW1hdGlvbkNDID0gJyEnLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHNpbmdsZVF1b3RlQ0MgPSBcIidcIi5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBkb3VibGVRdW90ZUNDID0gJ1wiJy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBvcGVuQ29ybmVyQnJhY2tldENDID0gJ1snLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGNsb3NlQ29ybmVyQnJhY2tldENDID0gJ10nLmNoYXJDb2RlQXQoMCk7XG5cblxuICAgIC8qKlxuICAgICAqIHBhcnNpbmcgYSBsaXN0IG9mIGVudHJpZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUNoaWxkcmVuKHRhZ05hbWUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgIHdoaWxlIChTW3Bvc10pIHtcbiAgICAgICAgICAgIGlmIChTLmNoYXJDb2RlQXQocG9zKSA9PSBvcGVuQnJhY2tldENDKSB7XG4gICAgICAgICAgICAgICAgaWYgKFMuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gc2xhc2hDQykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VTdGFydCA9IHBvcyArIDI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IFMuaW5kZXhPZihjbG9zZUJyYWNrZXQsIHBvcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlVGFnID0gUy5zdWJzdHJpbmcoY2xvc2VTdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlVGFnLmluZGV4T2YodGFnTmFtZSkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRUZXh0ID0gUy5zdWJzdHJpbmcoMCwgcG9zKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgY2xvc2UgdGFnXFxuTGluZTogJyArIChwYXJzZWRUZXh0Lmxlbmd0aCAtIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuQ29sdW1uOiAnICsgKHBhcnNlZFRleHRbcGFyc2VkVGV4dC5sZW5ndGggLSAxXS5sZW5ndGggKyAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbkNoYXI6ICcgKyBTW3Bvc11cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zICsgMSkgcG9zICs9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoUy5jaGFyQ29kZUF0KHBvcyArIDEpID09PSBleGNsYW1hdGlvbkNDKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChTLmNoYXJDb2RlQXQocG9zICsgMikgPT0gbWludXNDQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21tZW50IHN1cHBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29tbWVudFBvcyA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgIT09IC0xICYmICEoUy5jaGFyQ29kZUF0KHBvcykgPT09IGNsb3NlQnJhY2tldENDICYmIFMuY2hhckNvZGVBdChwb3MgLSAxKSA9PSBtaW51c0NDICYmIFMuY2hhckNvZGVBdChwb3MgLSAyKSA9PSBtaW51c0NDICYmIHBvcyAhPSAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBTLmluZGV4T2YoY2xvc2VCcmFja2V0LCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gUy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2VlcENvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChTLnN1YnN0cmluZyhzdGFydENvbW1lbnRQb3MsIHBvcyArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIFMuY2hhckNvZGVBdChwb3MgKyAyKSA9PT0gb3BlbkNvcm5lckJyYWNrZXRDQyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgUy5jaGFyQ29kZUF0KHBvcyArIDgpID09PSBvcGVuQ29ybmVyQnJhY2tldENDICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBTLnN1YnN0cihwb3MgKyAzLCA1KS50b0xvd2VyQ2FzZSgpID09PSAnY2RhdGEnXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2RhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZGF0YUVuZEluZGV4ID0gUy5pbmRleE9mKCddXT4nLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNkYXRhRW5kSW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKFMuc3Vic3RyKHBvcyArIDkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBTLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChTLnN1YnN0cmluZyhwb3MgKyA5LCBjZGF0YUVuZEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gY2RhdGFFbmRJbmRleCArIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvY3R5cGVzdXBwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydERvY3R5cGUgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5jYXBzdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChTLmNoYXJDb2RlQXQocG9zKSAhPT0gY2xvc2VCcmFja2V0Q0MgfHwgZW5jYXBzdWxlZCA9PT0gdHJ1ZSkgJiYgU1twb3NdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFMuY2hhckNvZGVBdChwb3MpID09PSBvcGVuQ29ybmVyQnJhY2tldENDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY2Fwc3VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5jYXBzdWxlZCA9PT0gdHJ1ZSAmJiBTLmNoYXJDb2RlQXQocG9zKSA9PT0gY2xvc2VDb3JuZXJCcmFja2V0Q0MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goUy5zdWJzdHJpbmcoc3RhcnREb2N0eXBlLCBwb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gcGFyc2VOb2RlKCk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lWzBdID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCguLi5ub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBwYXJzZVRleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoa2VlcFdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmltbWVkID0gdGV4dC50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmltbWVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godHJpbW1lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICAgIHJldHVybnMgdGhlIHRleHQgb3V0c2lkZSBvZiB0ZXh0cyB1bnRpbCB0aGUgZmlyc3QgJzwnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VUZXh0KCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBwb3M7XG4gICAgICAgIHBvcyA9IFMuaW5kZXhPZihvcGVuQnJhY2tldCwgcG9zKSAtIDE7XG4gICAgICAgIGlmIChwb3MgPT09IC0yKVxuICAgICAgICAgICAgcG9zID0gUy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBTLnNsaWNlKHN0YXJ0LCBwb3MgKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICAgcmV0dXJucyB0ZXh0IHVudGlsIHRoZSBmaXJzdCBub25BbHBoYWJldGljIGxldHRlclxuICAgICAqL1xuICAgIHZhciBuYW1lU3BhY2VyID0gJ1xcclxcblxcdD4vPSAnO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VOYW1lKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBwb3M7XG4gICAgICAgIHdoaWxlIChuYW1lU3BhY2VyLmluZGV4T2YoU1twb3NdKSA9PT0gLTEgJiYgU1twb3NdKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUy5zbGljZShzdGFydCwgcG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICAgaXMgcGFyc2luZyBhIG5vZGUsIGluY2x1ZGluZyB0YWdOYW1lLCBBdHRyaWJ1dGVzIGFuZCBpdHMgY2hpbGRyZW4sXG4gICAgICogdG8gcGFyc2UgY2hpbGRyZW4gaXQgdXNlcyB0aGUgcGFyc2VDaGlsZHJlbiBhZ2FpbiwgdGhhdCBtYWtlcyB0aGUgcGFyc2luZyByZWN1cnNpdmVcbiAgICAgKi9cbiAgICB2YXIgTm9DaGlsZE5vZGVzID0gb3B0aW9ucy5ub0NoaWxkTm9kZXMgfHwgWydpbWcnLCAnYnInLCAnaW5wdXQnLCAnbWV0YScsICdsaW5rJywgJ2hyJ107XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5vZGUoKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gcGFyc2VOYW1lKCk7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG5cbiAgICAgICAgLy8gcGFyc2luZyBhdHRyaWJ1dGVzXG4gICAgICAgIHdoaWxlIChTLmNoYXJDb2RlQXQocG9zKSAhPT0gY2xvc2VCcmFja2V0Q0MgJiYgU1twb3NdKSB7XG4gICAgICAgICAgICB2YXIgYyA9IFMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKChjID4gNjQgJiYgYyA8IDkxKSB8fCAoYyA+IDk2ICYmIGMgPCAxMjMpKSB7XG4gICAgICAgICAgICAgICAgLy9pZignYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicuaW5kZXhPZihTW3Bvc10pIT09LTEgKXtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHBhcnNlTmFtZSgpO1xuICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZ1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gUy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvZGUgJiYgY29kZSAhPT0gc2luZ2xlUXVvdGVDQyAmJiBjb2RlICE9PSBkb3VibGVRdW90ZUNDICYmICEoKGNvZGUgPiA2NCAmJiBjb2RlIDwgOTEpIHx8IChjb2RlID4gOTYgJiYgY29kZSA8IDEyMykpICYmIGNvZGUgIT09IGNsb3NlQnJhY2tldENDKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gUy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBzaW5nbGVRdW90ZUNDIHx8IGNvZGUgPT09IGRvdWJsZVF1b3RlQ0MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcG9zLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGlvbmFsIHBhcnNpbmcgb2YgY2hpbGRyZW5cbiAgICAgICAgaWYgKFMuY2hhckNvZGVBdChwb3MgLSAxKSAhPT0gc2xhc2hDQykge1xuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT0gXCJzY3JpcHRcIikge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgcG9zID0gUy5pbmRleE9mKCc8L3NjcmlwdD4nLCBwb3MpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gW1Muc2xpY2Uoc3RhcnQsIHBvcyldO1xuICAgICAgICAgICAgICAgIHBvcyArPSA5O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgcG9zID0gUy5pbmRleE9mKCc8L3N0eWxlPicsIHBvcyk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBbUy5zbGljZShzdGFydCwgcG9zKV07XG4gICAgICAgICAgICAgICAgcG9zICs9IDg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5vQ2hpbGROb2Rlcy5pbmRleE9mKHRhZ05hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gcGFyc2VDaGlsZHJlbih0YWdOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFnTmFtZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgICBpcyBwYXJzaW5nIGEgc3RyaW5nLCB0aGF0IHN0YXJ0cyB3aXRoIGEgY2hhciBhbmQgd2l0aCB0aGUgc2FtZSB1c3VhbGx5ICAnIG9yIFwiXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0cmluZygpIHtcbiAgICAgICAgdmFyIHN0YXJ0Q2hhciA9IFNbcG9zXTtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gcG9zICsgMTtcbiAgICAgICAgcG9zID0gUy5pbmRleE9mKHN0YXJ0Q2hhciwgc3RhcnRwb3MpO1xuICAgICAgICByZXR1cm4gUy5zbGljZShzdGFydHBvcywgcG9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRFbGVtZW50cygpIHtcbiAgICAgICAgdmFyIHIgPSBuZXcgUmVnRXhwKCdcXFxccycgKyBvcHRpb25zLmF0dHJOYW1lICsgJ1xcXFxzKj1bXFwnXCJdJyArIG9wdGlvbnMuYXR0clZhbHVlICsgJ1tcXCdcIl0nKS5leGVjKFMpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHIuaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5hdHRyVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmF0dHJOYW1lID0gb3B0aW9ucy5hdHRyTmFtZSB8fCAnaWQnO1xuICAgICAgICB2YXIgb3V0ID0gW107XG5cbiAgICAgICAgd2hpbGUgKChwb3MgPSBmaW5kRWxlbWVudHMoKSkgIT09IC0xKSB7XG4gICAgICAgICAgICBwb3MgPSBTLmxhc3RJbmRleE9mKCc8JywgcG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gocGFyc2VOb2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUyA9IFMuc3Vic3RyKHBvcyk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnBhcnNlTm9kZSkge1xuICAgICAgICBvdXQgPSBwYXJzZU5vZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgPSBwYXJzZUNoaWxkcmVuKCcnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgICAgb3V0ID0gZmlsdGVyKG91dCwgb3B0aW9ucy5maWx0ZXIpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNpbXBsaWZ5KSB7XG4gICAgICAgIHJldHVybiBzaW1wbGlmeShBcnJheS5pc0FycmF5KG91dCkgPyBvdXQgOiBbb3V0XSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2V0UG9zKSB7XG4gICAgICAgIG91dC5wb3MgPSBwb3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiB0cmFuc2Zvcm0gdGhlIERvbU9iamVjdCB0byBhbiBvYmplY3QgdGhhdCBpcyBsaWtlIHRoZSBvYmplY3Qgb2YgUEhQYHMgc2ltcGxlX3htcF9sb2FkXyooKSBtZXRob2RzLlxuICogdGhpcyBmb3JtYXQgaGVscHMgeW91IHRvIHdyaXRlIHRoYXQgaXMgbW9yZSBsaWtlbHkgdG8ga2VlcCB5b3VyIHByb2dyYW0gd29ya2luZywgZXZlbiBpZiB0aGVyZSBhIHNtYWxsIGNoYW5nZXMgaW4gdGhlIFhNTCBzY2hlbWEuXG4gKiBiZSBhd2FyZSwgdGhhdCBpdCBpcyBub3QgcG9zc2libGUgdG8gcmVwcm9kdWNlIHRoZSBvcmlnaW5hbCB4bWwgZnJvbSBhIHNpbXBsaWZpZWQgdmVyc2lvbiwgYmVjYXVzZSB0aGUgb3JkZXIgb2YgZWxlbWVudHMgaXMgbm90IHNhdmVkLlxuICogdGhlcmVmb3JlIHlvdXIgcHJvZ3JhbSB3aWxsIGJlIG1vcmUgZmxleGlibGUgYW5kIGVhc2llciB0byByZWFkLlxuICpcbiAqIEBwYXJhbSB7dE5vZGVbXX0gY2hpbGRyZW4gdGhlIGNoaWxkcmVuTGlzdFxuICovXG5mdW5jdGlvbiBzaW1wbGlmeShjaGlsZHJlbikge1xuICAgIHZhciBvdXQgPSB7fTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgY2hpbGRyZW5bMF0gPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICAvLyBtYXAgZWFjaCBvYmplY3RcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvdXRbY2hpbGQudGFnTmFtZV0pXG4gICAgICAgICAgICBvdXRbY2hpbGQudGFnTmFtZV0gPSBbXTtcbiAgICAgICAgdmFyIGtpZHMgPSBzaW1wbGlmeShjaGlsZC5jaGlsZHJlbik7XG4gICAgICAgIG91dFtjaGlsZC50YWdOYW1lXS5wdXNoKGtpZHMpO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY2hpbGQuYXR0cmlidXRlcykubGVuZ3RoICYmIHR5cGVvZiBraWRzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAga2lkcy5fYXR0cmlidXRlcyA9IGNoaWxkLmF0dHJpYnV0ZXM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgaW4gb3V0KSB7XG4gICAgICAgIGlmIChvdXRbaV0ubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIG91dFtpXSA9IG91dFtpXVswXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogc2ltaWxhciB0byBzaW1wbGlmeSwgYnV0IGxvc3QgbGVzc1xuICpcbiAqIEBwYXJhbSB7dE5vZGVbXX0gY2hpbGRyZW4gdGhlIGNoaWxkcmVuTGlzdFxuICovXG5mdW5jdGlvbiBzaW1wbGlmeUxvc3RMZXNzKGNoaWxkcmVuLCBwYXJlbnRBdHRyaWJ1dGVzID0ge30pIHtcbiAgICB2YXIgb3V0ID0ge307XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHR5cGVvZiBjaGlsZHJlblswXSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyZW50QXR0cmlidXRlcykubGVuZ3RoID8ge1xuICAgICAgICAgICAgX2F0dHJpYnV0ZXM6IHBhcmVudEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB2YWx1ZTogY2hpbGRyZW5bMF1cbiAgICAgICAgfSA6IGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICAvLyBtYXAgZWFjaCBvYmplY3RcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvdXRbY2hpbGQudGFnTmFtZV0pXG4gICAgICAgICAgICBvdXRbY2hpbGQudGFnTmFtZV0gPSBbXTtcbiAgICAgICAgdmFyIGtpZHMgPSBzaW1wbGlmeUxvc3RMZXNzKGNoaWxkLmNoaWxkcmVuIHx8IFtdLCBjaGlsZC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgb3V0W2NoaWxkLnRhZ05hbWVdLnB1c2goa2lkcyk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhjaGlsZC5hdHRyaWJ1dGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGtpZHMuX2F0dHJpYnV0ZXMgPSBjaGlsZC5hdHRyaWJ1dGVzO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBiZWhhdmVzIHRoZSBzYW1lIHdheSBhcyBBcnJheS5maWx0ZXIsIGlmIHRoZSBmaWx0ZXIgbWV0aG9kIHJldHVybiB0cnVlLCB0aGUgZWxlbWVudCBpcyBpbiB0aGUgcmVzdWx0TGlzdFxuICogQHBhcmFtcyBjaGlsZHJlbntBcnJheX0gdGhlIGNoaWxkcmVuIG9mIGEgbm9kZVxuICogQHBhcmFtIGZ7ZnVuY3Rpb259IHRoZSBmaWx0ZXIgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihjaGlsZHJlbiwgZiwgZGVwdCA9IDAsIHBhdGggPSAnJykge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkLCBpKSB7XG4gICAgICAgIGlmICh0eXBlb2YoY2hpbGQpID09PSAnb2JqZWN0JyAmJiBmKGNoaWxkLCBpLCBkZXB0LCBwYXRoKSkgb3V0LnB1c2goY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBraWRzID0gZmlsdGVyKGNoaWxkLmNoaWxkcmVuLCBmLCBkZXB0ICsgMSwgKHBhdGggPyBwYXRoICsgJy4nIDogJycpICsgaSArICcuJyArIGNoaWxkLnRhZ05hbWUpO1xuICAgICAgICAgICAgb3V0ID0gb3V0LmNvbmNhdChraWRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIHN0cmluZ2lmeSBhIHByZXZpb3VzbHkgcGFyc2VkIHN0cmluZyBvYmplY3QuXG4gKiB0aGlzIGlzIHVzZWZ1bCxcbiAqICAxLiB0byByZW1vdmUgd2hpdGVzcGFjZVxuICogMi4gdG8gcmVjcmVhdGUgeG1sIGRhdGEsIHdpdGggc29tZSBjaGFuZ2VkIGRhdGEuXG4gKiBAcGFyYW0ge3ROb2RlfSBPIHRoZSBvYmplY3QgdG8gU3RyaW5naWZ5XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeShPKSB7XG4gICAgdmFyIG91dCA9ICcnO1xuXG4gICAgZnVuY3Rpb24gd3JpdGVDaGlsZHJlbihPKSB7XG4gICAgICAgIGlmIChPKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIE9baV0gPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IE9baV0udHJpbSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlTm9kZShPW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cml0ZU5vZGUoTikge1xuICAgICAgICBvdXQgKz0gXCI8XCIgKyBOLnRhZ05hbWU7XG4gICAgICAgIGZvciAodmFyIGkgaW4gTi5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoTi5hdHRyaWJ1dGVzW2ldID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgJyArIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE4uYXR0cmlidXRlc1tpXS5pbmRleE9mKCdcIicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICcgKyBpICsgJz1cIicgKyBOLmF0dHJpYnV0ZXNbaV0udHJpbSgpICsgJ1wiJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgJyArIGkgKyBcIj0nXCIgKyBOLmF0dHJpYnV0ZXNbaV0udHJpbSgpICsgXCInXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE4udGFnTmFtZVswXSA9PT0gJz8nKSB7XG4gICAgICAgICAgICBvdXQgKz0gJz8+JztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJz4nO1xuICAgICAgICB3cml0ZUNoaWxkcmVuKE4uY2hpbGRyZW4pO1xuICAgICAgICBvdXQgKz0gJzwvJyArIE4udGFnTmFtZSArICc+JztcbiAgICB9XG4gICAgd3JpdGVDaGlsZHJlbihPKTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogdXNlIHRoaXMgbWV0aG9kIHRvIHJlYWQgdGhlIHRleHQgY29udGVudCwgb2Ygc29tZSBub2RlLlxuICogSXQgaXMgZ3JlYXQgaWYgeW91IGhhdmUgbWl4ZWQgY29udGVudCBsaWtlOlxuICogdGhpcyB0ZXh0IGhhcyBzb21lIDxiPmJpZzwvYj4gdGV4dCBhbmQgYSA8YSBocmVmPScnPmxpbms8L2E+XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvQ29udGVudFN0cmluZyh0RG9tKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodERvbSkpIHtcbiAgICAgICAgdmFyIG91dCA9ICcnO1xuICAgICAgICB0RG9tLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArIHRvQ29udGVudFN0cmluZyhlKTtcbiAgICAgICAgICAgIG91dCA9IG91dC50cmltKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHREb20gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0b0NvbnRlbnRTdHJpbmcodERvbS5jaGlsZHJlbilcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyAnICsgdERvbTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50QnlJZChTLCBpZCwgc2ltcGxpZmllZCkge1xuICAgIHZhciBvdXQgPSBwYXJzZShTLCB7XG4gICAgICAgIGF0dHJWYWx1ZTogaWRcbiAgICB9KTtcbiAgICByZXR1cm4gc2ltcGxpZmllZCA/IHRYbWwuc2ltcGxpZnkob3V0KSA6IG91dFswXTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRzQnlDbGFzc05hbWUoUywgY2xhc3NuYW1lLCBzaW1wbGlmaWVkKSB7XG4gICAgY29uc3Qgb3V0ID0gcGFyc2UoUywge1xuICAgICAgICBhdHRyTmFtZTogJ2NsYXNzJyxcbiAgICAgICAgYXR0clZhbHVlOiAnW2EtekEtWjAtOS0gXSonICsgY2xhc3NuYW1lICsgJ1thLXpBLVowLTktIF0qJ1xuICAgIH0pO1xuICAgIHJldHVybiBzaW1wbGlmaWVkID8gdFhtbC5zaW1wbGlmeShvdXQpIDogb3V0O1xufVxuXG5leHBvcnQgeyBmaWx0ZXIsIGdldEVsZW1lbnRCeUlkLCBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lLCBwYXJzZSwgc2ltcGxpZnksIHNpbXBsaWZ5TG9zdExlc3MsIHN0cmluZ2lmeSwgdG9Db250ZW50U3RyaW5nIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/txml/dist/txml.mjs\n");

/***/ })

};
;