{"version":3,"file":"align.js","sourceRoot":"","sources":["../src/align.ts"],"names":[],"mappings":"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","sourcesContent":["import { getTextByPathList } from './utils';\r\nimport type { HorizontalAlign, VerticalAlign, XmlNode, ProcessingContext } from './types';\r\n\r\nexport function getHorizontalAlign(\r\n  node: XmlNode, \r\n  pNode: XmlNode, \r\n  type: string | undefined, \r\n  warpObj: ProcessingContext\r\n): HorizontalAlign {\r\n  let algn = getTextByPathList(node, ['a:pPr', 'attrs', 'algn']);\r\n  if (!algn) {\r\n    algn = getTextByPathList(pNode, ['a:pPr', 'attrs', 'algn']);\r\n  }\r\n\r\n  if (!algn) {\r\n    if (type === 'title' || type === 'ctrTitle' || type === 'subTitle') {\r\n      let lvlIdx = 1;\r\n      const lvlNode = getTextByPathList(pNode, ['a:pPr', 'attrs', 'lvl']);\r\n      if (lvlNode) {\r\n        lvlIdx = parseInt(lvlNode) + 1;\r\n      }\r\n      const lvlStr = 'a:lvl' + lvlIdx + 'pPr';\r\n      \r\n      algn = getTextByPathList(warpObj.slideLayoutTables, ['typeTable', type, 'p:txBody', 'a:lstStyle', lvlStr, 'attrs', 'algn']);\r\n      if (!algn) {\r\n        algn = getTextByPathList(warpObj.slideMasterTables, ['typeTable', type, 'p:txBody', 'a:lstStyle', lvlStr, 'attrs', 'algn']);\r\n      }\r\n      if (!algn) {\r\n        algn = getTextByPathList(warpObj.slideMasterTextStyles, ['p:titleStyle', lvlStr, 'attrs', 'algn']);\r\n      }\r\n      if (!algn && type === 'subTitle') {\r\n        algn = getTextByPathList(warpObj.slideMasterTextStyles, ['p:bodyStyle', lvlStr, 'attrs', 'algn']);\r\n      }\r\n    } else if (type === 'body') {\r\n      algn = getTextByPathList(warpObj.slideMasterTextStyles, ['p:bodyStyle', 'a:lvl1pPr', 'attrs', 'algn']);\r\n    } else if (type) {\r\n      algn = getTextByPathList(warpObj.slideMasterTables, ['typeTable', type, 'p:txBody', 'a:lstStyle', 'a:lvl1pPr', 'attrs', 'algn']);\r\n    }\r\n  }\r\n\r\n  if (algn) {\r\n    switch (algn) {\r\n      case 'l':\r\n        return 'left';\r\n      case 'r':\r\n        return 'right';\r\n      case 'ctr':\r\n        return 'center';\r\n      case 'just':\r\n      case 'dist':\r\n        return 'justify';\r\n      default:\r\n        return 'left';\r\n    }\r\n  }\r\n  \r\n  return 'left';\r\n}\r\n\r\nexport function getVerticalAlign(\r\n  node: XmlNode, \r\n  slideLayoutSpNode?: XmlNode | null, \r\n  slideMasterSpNode?: XmlNode | null\r\n): VerticalAlign {\r\n  let anchor = getTextByPathList(node, ['p:txBody', 'a:bodyPr', 'attrs', 'anchor']);\r\n  \r\n  if (!anchor) {\r\n    anchor = getTextByPathList(slideLayoutSpNode, ['p:txBody', 'a:bodyPr', 'attrs', 'anchor']);\r\n    if (!anchor) {\r\n      anchor = getTextByPathList(slideMasterSpNode, ['p:txBody', 'a:bodyPr', 'attrs', 'anchor']);\r\n      if (!anchor) {\r\n        anchor = 't';\r\n      }\r\n    }\r\n  }\r\n  \r\n  if (anchor === 'ctr') return 'mid';\r\n  if (anchor === 'b') return 'bottom';\r\n  return 'top';\r\n}"]}